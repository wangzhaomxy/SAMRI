import os
import glob
import h5py as h5
import numpy as np
import nibabel as nib
import cv2
import json
from tqdm import tqdm
# import SimpleITK as sitk


def read_nii_file(path):
    """
    Read the nifty (.nii.gz) file and return numpy format.
    
    Args:
        path(str): The path of a image with the format of path/xxx.nii.gz

    Returns:
        (np.array): the numpy format of the input nifty image.

    """
    return nib.load(path).get_fdata()

def read_BTDF_file(path):
    """
    Read the .mat file and convert the image and mask file into numpy format.
    The data structure in .mat file is as follows:
    
        cjdata.label: 1 for meningioma, 2 for glioma, 3 for pituitary tumor
        
        cjdata.PID: patient ID
        
        cjdata.image: image data , shape: 512 x 512
        
        cjdata.tumorBorder: a vector storing the coordinates of discrete points 
                on tumor border. For example, [x1, y1, x2, y2,...] in which x1, 
                y1 are planar coordinates on tumor border. It was generated by 
                manually delineating the tumor border. So we can use it to 
                generate binary image of tumor mask.
                
        cjdata.tumorMask: a binary label image, shape: 512 x 512
    
    Args:
        path(str): The path of a image with the format of path/xxx.mat

    Returns:
        filename(str): the strings of file name without .mat. For example: x.mat
                        will return x
                        
        image(np.array): the numpy format of the input image.
        
        label(str): label classes(1,2,3) with the return of label1,label2,label3
        
        tumormask(np.array): the numpy format of the mask.
    """
    data = h5.File(path)
    data = data['cjdata']
    filename = fname_from_path(path)[:-4]
    # The entire dataset contains five keys: PID, image, label, tumorBorder, and
    # tumorMask. However, here we just need image, label and tumorMask for study.
    image, label, tumormask = data['image'], data['label'], data['tumorMask']
    return filename, np.array(image), "label"+str(int(np.array(label).item()))\
            ,np.array(tumormask)

def save_nib_data(path, filename, image, mask, 
                  label="label0", 
                  modality="T2",
                  sli_idx = "0000"):
    """
    Save images and masks to .nii.gz format. Input save path, filename, image
    data, label string and mask data, save image and mask data as [1,w,h] shape.
    """
    image_name = path + filename + "_" + label + "_" + modality + "_img_" + \
                                                            sli_idx + ".nii.gz"
    mask_name =  path + filename + "_" + label + "_" + modality + "_seg_" + \
                                                            sli_idx + ".nii.gz"
    new_image = nib.Nifti1Image(np.expand_dims(image, axis=0), np.eye(4))
    new_mask = nib.Nifti1Image(np.expand_dims(mask, axis=0), np.eye(4))
    nib.save(new_image, image_name)
    nib.save(new_mask, mask_name)

def save_img_data(path, filename, image, mask, 
                  label="label0", 
                  modality="T2",
                  sli_idx = "0000"):
    """
    Save images and masks to .png format. Input save path, filename, image
    data, label string and mask data, save image and mask data as [w,h] shape.
    """
    image_name = path + "img/" + filename + "_" + label + "_" + modality + \
                                                "_img_" + sli_idx + ".png"
    mask_name = path + "mask/" + filename + "_" + label + "_" + modality + \
                                                "_seg_" + sli_idx + ".png"
    comb_name = path + "combination/" + filename + "_" + label + "_" + modality\
                                                + "_comb_" + sli_idx + ".png"
    image = min_max_norm(image) * 255
    mask = mask * 255
    comb_img = np.concatenate([image, mask, (image+mask)/2], axis=1)
    cv2.imwrite(image_name, image)
    cv2.imwrite(mask_name, mask)
    cv2.imwrite(comb_name, comb_img)

def min_max_norm(image):
    return (image - np.min(image))/(np.max(image)-np.min(image)+ 1e-10)

def create_save_folder(root_path):
    """
    
    Create two new folders to save processed nifiy files and image files if
    the two folders do not exist.

    Args:
        root_path (str): the root path of the processing dataset. For example,
                        "D:/xxxx/xxxx/xxxx
    
    Returns:
        (str) : The path saving processed nifty files.
        (str) : The path saving processed image files.
        
    """
    save_path = root_path + "/processed_data/"
    save_img_path = root_path + "/processed_img/"

    for sub_path in (save_path, save_img_path):
        make_dir(sub_path)
        
    create_folders(save_img_path, ["img/", "mask/", "combination/"])
    
    return save_path, save_img_path

def create_folders(root_path, folder_names):
    """
    Create multiple new folders with names in folder_names list under root_path 
    if the folders do not exist.

    Args:
        root_path (str): the root path of the image saving folder. For example,
                            D:/xxxx/xxxx/xx/
        folder_names (list): the list of folder names. For example, 
                                ["name1/", "name2/", ...]

    Returns:
        No returns.
    """
    paths = [root_path + fo_name for fo_name in folder_names]

    for sub_path in paths:
        make_dir(sub_path)

def make_dir(path):
    if not os.path.exists(path):
        os.makedirs(path)
        


def include(ds_root, ds_name):
    """
    Check if the ds_root include the ds_names in the ds_name list.

    Args:
        ds_root (str): The data set root path.
        ds_name (list): The list of dataset names from keys of the ds_name Dic.

    Returns:
        (Bool): "True" if contains, else "False"
    """
    for name in ds_name:
        if name in ds_root:
            return True
    return False

def fname_from_path(path):
    """
    Get folder/file name from the path, i.e. the last string after the last "/".

    Args:
        path (str): The path string.
        
    Returns:
        (str): The folder/file name.
    """
    return os.path.basename(path)

def sort_all_fnames(path):
    """
    List all the file names (absolute path) and sort in descend order.

    Args:
        path (str): The path of the folder. For example, D:/xxx/xxx/xxx .

    Returns:
        [list]: A list of all file names (absolute path) under the input folder.
    """
    return sorted(glob.glob(path + "/*"))

def sort_key_fnames(path, key):
    """
    List all the file names (absolute path) containing key words and sort in 
    descend order.

    Args:
        path (str): The path of the folder. For example, D:/xxx/xxx/xxx.
        key (str): The key string 

    Returns:
        [list]: A list of all file names (absolute path) under the input folder.
    """
    return sorted(glob.glob(path + "/*" + key +"*"))

def read_json(path):
    """
    Read .json files under the path folder.

    Args:
        path (Str): The folder path. For example, D:/xxx/xxx/xxx .

    Returns:
        {Dic}: the Dictionary read from the .json file.
    """
    
    with open(glob.glob(path + "/*.json")[0]) as json_data:
        js_data = json.load(json_data)
        json_data.close()        
    return js_data

def process_nii_json(json_ds, root_path, ds_info, save_nii_path_out, 
                     save_img_path_out):
    for data in tqdm(json_ds):
        img_nD = read_nii_file(root_path + '/' + data["image"])
        gt_nD = read_nii_file(root_path + '/' + data["label"])
        
        slices = img_nD.shape[2]
        for i in range(len(ds_info["modality"])):
            for slice_num in range(slices):
                filename = fname_from_path(data["image"])[:-7]
                modality=ds_info["modality"][str(i)]
                sli_idx = str(slice_num).zfill(4)
                if len(np.nonzero(gt_nD[:,:,slice_num])[0]) > 30:
                    if len(img_nD.shape) == 4:
                        image = img_nD[:,:,slice_num,i]
                    if len(img_nD.shape) == 3:
                        image = img_nD[:,:,slice_num]                            
                    mask = gt_nD[:,:,slice_num]
                    
                    save_nib_data(save_nii_path_out, filename, image, mask, 
                                            modality=modality, sli_idx=sli_idx)
                    save_img_data(save_img_path_out, filename, image, mask, 
                                            modality=modality, sli_idx=sli_idx)
                    
# def load_itk(mhd_name):
#     """
#     Read a ".mhd" file using SimpleITK and teturn the image array

#     Args:
#         mhd_name (str): The ".mhd" file path.

#     Returns:
#         np.array: The 3D image in numpy array format.
#     """
#     itkimage = sitk.ReadImage(mhd_name)
#     np_img = sitk.GetArrayFromImage(itkimage)
#     return np_img

def read_npz(path):
    """
    Read .npz files from path and return a file name, image and mask.

    Args:
        path (str): The absolute path of .npz file.

    Returns:
        (str): The file name (The last strings behind the last "/", without 
                                                        extention file name).
        (np.array): the image with the shape of CWH.
        (np.array): the mask with the shape of CWH.
    """
    data = np.load(path)
    filename = fname_from_path(path)[:-4]

    image, mask = data['imgs'], data['gts']
    return filename, image, mask

def slice_np(image, mask, filename,
              threshold:30, 
              save_nii_path_out,
              save_img_path_out):
    """
    Slice 3D image and mask and save file as nifty and png files.

    Args:
        image (np.array): The image with shape of CHW
        mask (np.array): The mask with shape of CHW, the same with image.
        filename (str): The file name (exlucive extention name).
        threshold (int): The threshold of mask labels.
        save_nii_path_out (str): The path for saving nifty files.
        save_img_path_out (str): The path for saving png files.
        
    Returns:
        No returns, saving files to the paths.
    """
    slices = image.shape[0]
    for slice_num in range(slices):
        modality = ""
        sli_idx = str(slice_num).zfill(4)
        if len(np.nonzero(mask[slice_num,:,:])[0]) > threshold:
            img = image[slice_num,:,:]                            
            gt = mask[slice_num,:,:]
            save_nib_data(save_nii_path_out, filename, img, gt, 
                                            modality=modality, sli_idx=sli_idx)
            save_img_data(save_img_path_out, filename, img, gt, 
                                            modality=modality, sli_idx=sli_idx)






